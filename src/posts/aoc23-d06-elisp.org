#+title: Advent of Code '23 - day 6
#+date: <2023-12-06 Wed>
\usepackage{mathtools}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}


#+begin_preview
Am easier puzzle this time!  This time I was able to solve it with pure math, with the only loop involved being in the input parser for part 1.  
#+end_preview

* Input
** Example
#+name: example
#+begin_example
Time:      7  15   30
Distance:  9  40  200
#+end_example

** Input                                                           :noexport:
#+name: input
#+begin_example
Time:        41     66     72     66
Distance:   244   1047   1228   1040
#+end_example

* Part 1
I was able to reduce the calculation into a single formula without loops, except for input parsing and adding everyrhi g together ofcourse.  i've split the formula into several methods as I expected a twist for part two.

Looking at the first example written out I recognized a bell curve.  Which means there is an apex point somewhere around the middle.  Running a few tests (with a little added round up/down).

\begin{equation}
distmax(tmax) = (\frac{t}{2})^2
\end{equation}

It matched perfectly which meant that we had already found 1 part of our equation.  To get to our answer we had to find the point where the time we pressed the button created enough distance to pass the distance threshold.  It had to be something that is the calculates the time difference between the minimum and maximum distance.  Looking at our previous formula I had the feeling I could use the square root here.  Giving it a spin I found that taking the square root of the difference between the max distance and the minimum distance matched up with the examples pretty well.  
 The value I got was the time we needed to press the button before releasing it.  

\begin{equation}
timemin(time, distmin) = \lfloor (\frac{time}{2}- \sqrt{distmax - distmin} )+1 \rfloor
\end{equation}

\begin{equation}
options(timeavailable, timemin)=time-(timemin *2)+1
\end{equation}


Were we to combine all equations into one it would look like the following:
\begin{equation}
options(t,d)=t-(\lfloor (\frac{t}{2}- \sqrt{((\frac{t}{2})^2) - d} )+1 \rfloor) *2)+1
\end{equation}

I'm no mathemitian so it might be optimized somehow, but I don't know.

#+begin_src elisp :var input=input
(defun aoc23/parse-input (string)
  (let* ((lines (string-split (string-trim string)
                              "\n"))
         (times (car lines))
         (times (string-trim (cadr (string-split times
                                                 ":"))))
         (times (string-split times
                              " +"))
         (times (mapcar 'string-to-number
                        times))
         (dists (cadr lines))
         (dists (string-trim (cadr (string-split dists
                                                 ":"))))
         (dists (string-split dists
                              " +"))
         (dists (mapcar 'string-to-number
                        dists))
         (output '()))
    
    (while times
      (setq output (append output
                           `((,(car times) . ,(car dists)))))
      (setq times (cdr times))
      (setq dists (cdr dists)))

    output))

(defun aoc23/calc-dist (time-pressed time-available)
  (* time-pressed (- time-available
                     time-pressed))
  )

(defun aoc23/calc-max-dist (time-available)
  (* (/ time-available 2.0)
     (/ time-available 2.0)))

(defun aoc23/calc-min-time (time-available min-distance)
  (floor (1+ (- (/ time-available 2.0)
                (sqrt (- (aoc23/calc-max-dist time-available)
                         min-distance))))))

(defun aoc23/calc-number-options (time-available min-distance)
  (1+ (- time-available
         (* 2
            (aoc23/calc-min-time time-available
                                 min-distance)))))
(apply '*
       (mapcar (lambda (c)
                 (aoc23/calc-number-options (car c) (cdr c)))
               (aoc23/parse-input input)))

#+end_src

#+RESULTS:
: 74698

* Part 2
  This part only required a different input-parser, yay!
#+begin_src elisp :var input=input
(defun aoc23/parse-input (string)
  (let* ((lines (string-split (string-trim string)
                              "\n"))
         (times (car lines))
         (times (string-trim (cadr (string-split times
                                                 ":"))))
         (times (string-split times
                              " +"))
        
         (dists (cadr lines))
         (dists (string-trim (cadr (string-split dists
                                                 ":"))))
         (dists (string-split dists
                              " +")))
    `((,(string-to-number (apply 'concat  times)) . ,(string-to-number (apply 'concat dists))))))

(defun aoc23/calc-dist (time-pressed time-available)
  (* time-pressed (- time-available
                     time-pressed))
  )

(defun aoc23/calc-max-dist (time-available)
  (* (/ time-available 2.0)
     (/ time-available 2.0)))

(defun aoc23/calc-min-time (time-available min-distance)
  (floor (1+ (- (/ time-available 2.0)
                (sqrt (- (aoc23/calc-max-dist time-available)
                         min-distance))))))

(defun aoc23/calc-number-options (time-available min-distance)
  (1+ (- time-available
         (* 2
            (aoc23/calc-min-time time-available
                                 min-distance)))))
(apply '*
       (mapcar (lambda (c)
                 (aoc23/calc-number-options (car c) (cdr c)))
               (aoc23/parse-input input)))

#+end_src

#+RESULTS:
: 27563421
